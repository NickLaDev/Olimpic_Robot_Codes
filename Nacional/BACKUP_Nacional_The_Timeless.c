#pragma config(Sensor, S1,     ARDU,           sensorI2CCustom)
#pragma config(Sensor, S2,     corDir,         sensorEV3_Color, modeEV3Color_RGB_Raw)
#pragma config(Sensor, S3,     corEsq,         sensorEV3_Color, modeEV3Color_RGB_Raw)
#pragma config(Sensor, S4,     giroscopio,     sensorEV3_Gyro)
#pragma config(Motor,  motorA,          traz,          tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorB,          esquerda,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          direita,       tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


int d=3;
float pp=3.14;

void motorg (int grausE, int forcae , int grausD, int forcad)
{
	moveMotorTarget(esquerda,grausE,forcae);
	moveMotorTarget(direita,grausD,forcad);
	waitUntilMotorStop(esquerda);
	waitUntilMotorStop(direita);
	sleep(100);
}

void parar()
{
	motor[direita]=0;
	motor[esquerda]=0;
	waitUntilMotorStop(esquerda);
	waitUntilMotorStop(direita);
}

void andar(int forcaee, int forcadd)
{
	motor[esquerda]=forcaee;
	motor[direita]=forcadd;

}

void andacm(int cm,int forcaa)
{


	moveMotorTarget(esquerda,forcaa,(pp*d/360)*cm);
	moveMotorTarget(direita,forcaa,(pp*d/360)*cm);
	waitUntilMotorStop(esquerda);
	waitUntilMotorStop(direita);

}


int distF, erro, vnD, vnE, luzE, luzD, FE, FD, lastErro, distL, distBD, distBE;
int dist, i2cAtivado=0;


float kp=1.6;
float kd=15;

bool verdeFalsoR;

int graus;
int Fmin=35;
int grause;
int controle;
int distD;
int distE;

int teste;


int pretoE=16;
int pretoD=21;//de 15 ate 32


int brancoE=190;
int brancoD=176;



int verdeE= 30;
int verdeD=26;


int cinzaE=130;
int cinzaD=137;

int x;
byte I2Cmessage[22];
char I2Creply[20];
int cinzaSE=170;
int cinzaSD=170;
int ladoObst=3;

int FminO=20;
bool verdeFalsoL;
int incli;

int controle1;
float kpp=0.3;

long RedE, RedD, GreenE, GreenD, BlueE, BlueD;

task sensores() ;//pronta
task tela() ;//pronta
task seguir();//pronta
task obstaculo();//pronto
task verdE();//pronto
task verdD();//pronto
task verdeFalsoE();//pronta
task verdeFalsoD();//pronta
task verSala3();
task sala3();
int i2c_msg(byte rec_address, int message_size,int return_size, ubyte byte0, ubyte byte1, ubyte byte2, ubyte byte3,ubyte byte4)

{
	memset(I2Creply, 0, sizeof(I2Creply));

	message_size = message_size+3;

	I2Cmessage[0] = message_size;
	I2Cmessage[1] = rec_address*2;
	I2Cmessage[2] = byte0;
	I2Cmessage[3] = byte1;
	I2Cmessage[4] = byte2;
	I2Cmessage[5] = byte3;
	I2Cmessage[6] = byte4;

	sendI2CMsg(S1, &I2Cmessage[0], return_size);
	wait1Msec(25);

	readI2CReply(S1, &I2Creply[0], return_size);

	x = I2Creply[0];

	wait1Msec(10);

	return x;

}

void sensorB()
{
	distBD=i2c_msg(8,1,1,5,0,0,0,0);
	distBE=i2c_msg(8,1,1,6,0,0,0,0);
}


task main()

{



	motor(traz)=100;
	sleep(2000);
	motor(traz)=0;
	setMotorBrakeMode(traz,0);

	startTask(sensores);
	startTask (tela);

	/*	resetGyro(giroscopio);
	sleep(100);
	while(incli<90)
	{
	andar(40,-40)


	}parar();*/
	while(1)
	{
		if(getButtonPress(buttonRight))
		{




			startTask(seguir);
			startTask(obstaculo);
			startTask(verdE);
			startTask(verdD);
			startTask(verdeFalsoD);
			startTask(verdeFalsoE);
			startTask(verSala3);
			//startTask(curva90);
		}
		sleep(10);
	}//fim do while

}//fim da task mein

task sensores()
{
	while(1)
	{
		luzE=SensorValue[corEsq];//descobre valor dos sensore Direito
		luzD=SensorValue[corDir];//descobre valor do sensor Esquerdo
		incli=getGyroDegrees(giroscopio);
		dist=i2c_msg(8,1,1,2,0,0,0,0);
		distD=i2c_msg(8,1,1,3,0,0,0,0);
		distE=i2c_msg(8,1,1,4,0,0,0,0);
		if(i2cAtivado==1) sensorB();
		getColorRGB(corDir,RedD,GreenD,BlueD);//descobre valor do RGB
		getColorRGB(corEsq, RedE, GreenE,BlueE);//descobre valor do sensor
		graus=getMotorEncoder(direita);//descobre valor do ENCOLDERDIREITO
		grause=getMotorEncoder(esquerda);//descobre valor do ENCONDERESQUERO
		sleep(1);
	}
}
task tela()
{
	while(1)



	{
		//displayBigTextLine(2,"RedD: %d",RedD);
		//	displayBigTextLine(4,"RedE: %d",RedE);
		//	displayBigTextLine(6,"GreenD:%d",GreenD);
		//displayBigTextLine(8,"GreenE:%d",GreenE);

		displayBigTextLine(8,"graus: %d",incli);//MOSTRA OS VALORES NA TELA
		displayBigTextLine(10,"distD: %d", distD);//MOSTRA OS VALORES NA TELA
		displayBigTextLine(12,"distE: %d", distE);//MOSTRA OS VALORES NA TELA
		displayBigTextLine(2,"SensorE: %d",luzE);//MOSTRA OS VALORES NA TELA
		displayBigTextLine(4,"SensorD: %d",luzD);//MOSTRA OS VALORES NA TELA
		displayBigTextLine(6,"gra: %d",graus);
		displayBigTextLine(14,"distF: %d",dist);


		sleep(500);
	}
}


task seguir()//seguir linha
{
	while(1)
	{
		vnE = (100*(luzE-pretoE))/(brancoE-pretoE);//calcula valor normalizado Esquerdo
		vnD = (100*(luzD-pretoD))/(brancoD-pretoD);//calcula valor normalizado Direito

		if (vnD>100) vnD=100;//SE O VALOR DO VND FOR ALTO MOTOR RAPIDO
			if (vnD<0) vnD=0;//se vnd for baixa motor lento
			if (vnE>100) vnE=100;//SE O VALOR DO VNE FOR ALTO MOTOR RAPIDO
			if (vnE<0) vnE=0;//se vnd for baixa motor lento

		erro=vnE-vnD;//descobre erro

		FE=Fmin+(kp*erro)+kd*(erro-lastErro);//descobre força dos motores
		FD=Fmin-(kp*erro)-kd*(erro-lastErro);//descobre força dos motores

		lastErro=erro;//lastErro

		motor[esquerda]=FE;//faz ele anda
		motor[direita]=FD;//faz ele anda

		sleep(10);//quantas vezes ele vai checar o sensor
	}
}







task obstaculo()
{/*
	while(1)
	{
	if (dist<=4)//se a distancia ficar pequena

	{
	if(ladoObst==1){//curva de 90 para esquerda //
	setSoundVolume(100);
	stopTask(verdeFalsoD);
	stopTask(verdeFalsoE);
	stopTask(verdD);
	stopTask(verdE);                  //paratasks
	stopTask(seguir);

	motor[direita]=0;//parar motores
	motor[esquerda]=0; //parar motores
	sleep(300);
	if(vnD<=93&&controle1==0)//descobre o lado da curva pelo valor normalizado
	{
	controle1=1;
	playTone(1000,100);

	motorg(20,30,20,30);

	motorg(230,30,230,-30);

	motorg(245,30,245,-30);

	motorg(240,-30,240,-30);

	while((luzD>=pretoD +23|| luzE>=pretoE+23) && graus<450) //while do alinhamento
	{
	if(luzD>=pretoD+38&&luzE>=pretoE+38)
	{playSound(soundException);
	motor(esquerda)=7;
	motor(direita)=7;
	}//fim do if td branco
	if(luzD<=pretoD+38)
	{
	playTone(1000,100);
	motor(direita)=-10;
	motor(esquerda)=10;
	}//fim do preto na direita
	if(luzE<=pretoE+38)
	{
	motor(direita)=10;
	motor(esquerda)=-10;
	////preto no esq
	}//fim do while de alihamento
	motor(direita)=0;
	motor(esquerda)=0;
	}
	if(vnE<=93&&controle1==0)
	{
	playSound(soundBeepBeep);
	//////setLEDColor(ledOff);
	controle1=1;

	moveMotorTarget(esquerda, 19, 30);
	moveMotorTarget(direita, 19, 30);
	waitUntilMotorStop(esquerda);
	waitUntilMotorStop(direita);
	moveMotorTarget(esquerda, 290, 30);
	moveMotorTarget(direita, 290, -30);
	waitUntilMotorStop(esquerda);
	waitUntilMotorStop(direita);


	while((luzD>=pretoD+23||luzE>=pretoE+23) && graus>-450) //while do alinhamento
	{
	if(luzD>=pretoD+38&&luzE>=pretoE+38)
	{
	motor(esquerda)=-10;
	motor(direita)=-10;

	}//fim do if td branco
	if(luzD<=pretoD+38)
	{
	motor(direita)=10;
	motor(esquerda)=-10;
	}//fim do preto na direita
	if(luzE<=pretoE+38)
	{
	motor(direita)=-10;
	motor(esquerda)=10;
	}//preto no esq
	}//fim do while de alihamento
	motor(esquerda)=0;
	motor(direita)=0;
	}
	playTone(9000,1000);

	if(vnD>93&&vnE>93)
	{
	motorg(400,30,400,-30);
	while((luzD>=pretoD+23||luzE>=pretoE+23) && graus>-450) //while do alinhamento
	{
	if(luzD>=pretoD+38&&luzE>=pretoE+38)
	{
	motor(esquerda)=-10;
	motor(direita)=-10;
	}//fim do if td branco
	if(luzD<=pretoD+38)
	{
	motor(direita)=10;
	motor(esquerda)=-10;
	}//fim do preto na direita
	if(luzE<=pretoE+38)
	{
	motor(direita)=-10;
	motor(esquerda)=10;
	}//preto no esq
	}//fim do while de alihamento
	motor(esquerda)=0;
	motor(direita)=0;
	}
	playTone(1000,100);
	controle1=0;
	while(distL>15)
	{
	motor[direita]=30;
	motor[esquerda]=30;
	}
	motor[direita]=0;
	motor[esquerda]=0;
	while(distL<15)
	{
	motor[direita]=30;
	motor[esquerda]=30;
	}
	motor[direita]=0;
	motor[esquerda]=0;
	motorg(400,-30,400,30);
	while(distL>15)
	{

	motor(esquerda)=30;
	motor(direita)=30;
	}
	resetMotorEncoder(direita);
	sleep(100);//reseta o enconder
	while(distL<15)
	{
	motor(esquerda)=30;
	motor(direita)=30;
	}
	motor(esquerda)=0;
	motor(direita)=0;
	graus=getMotorEncoder(direita);
	stopTask(verdD);
	stopTask(verdE);
	motorg(70,-40,70,-40);
	motorg(400,-40,400,40);
	motorg(220,40,220,40);
	while(luzE > pretoE+10)
	{
	motor[esquerda]=30;
	motor[direita]=30;
	}
	motor[esquerda]=0;
	motor[direita]=0;
	motorg(120,40,120,40);
	motorg(400,-30,400,30);
	resetMotorEncoder(direita);
	motorg(40,-30,40,-30);
	clearTimer(T3);

	while(distF>=3 && time1[T3]<=450)
	{
	vnE = (100*(luzE-pretoE))/(brancoE-pretoE);//calcula valor normalizado
	vnD = (100*(luzD-pretoD))/(brancoD-pretoD);
	if (vnD>100) vnD=100;
	if (vnD<0) vnD=0;
	if (vnE>100) vnE=100;
	if (vnE<0) vnE=0;
	erro=vnE-vnD;//descobre erro
	FE=Fmin+(kp*erro)+kd*(erro-lastErro);//descobre força ara os motores
	FD=Fmin-(kp*erro)-kd*(erro-lastErro);
	lastErro=erro;//lastErro
	motor[esquerda]=FE;//faz ele anda
	motor[direita]=FD;
	sleep(10);//quantas vezes ele vai checar o sensor
	}
	motor(esquerda)=0;
	motor(direita)=0;
	motorg(150,-30,150,-30);
	clearTimer(T3);
	while(distF>=3 && time1[T3]<=330)
	{
	vnE = (100*(luzE-pretoE))/(brancoE-pretoE);//calcula valor normalizado
	vnD = (100*(luzD-pretoD))/(brancoD-pretoD);
	if (vnD>100) vnD=100;
	if (vnD<0) vnD=0;
	if (vnE>100) vnE=100;
	if (vnE<0) vnE=0;
	erro=vnE-vnD;//descobre erro
	FE=Fmin+(kp*erro)+kd*(erro-lastErro);//descobre força ara os motores
	FD=Fmin-(kp*erro)-kd*(erro-lastErro);
	lastErro=erro;//lastErro
	motor[esquerda]=FE;//faz ele anda
	motor[direita]=FD;
	sleep(10);//quantas vezes ele vai checar o sensor
	}


	resetMotorEncoder(direita);
	sleep(100);
	controle=0;

	motorg(170,-30,170,-30);

	resetMotorEncoder(direita);
	while(graus>=-400 && controle==0)
	{
	motor(esquerda)=-7;
	motor(direita)=-7;
	if(graus<-130 && controle==0)
	{//////setLEDColor(ledOff);
	controle=5;
	}
	else	if(luzE<pretoE+20&&luzD>brancoD-70&&controle==0)
	{
	sleep(100);
	if(luzE > verdeE - 15 && luzE < verdeE + 15 && GreenE - RedE > 6 &&  controle==0)
	{
	motor(esquerda)=0;
	motor(direita)=0;
	sleep(100);
	controle=4;
	}
	else
	{

	motor(esquerda)=0;
	motor(direita)=0;
	sleep(100);
	controle=2;
	}
	}
	else	if(luzD<pretoD+20 && luzE>brancoE-70 && controle==0)
	{
	sleep(100);
	if(luzD > verdeD - 15 && luzD < verdeD + 15 && GreenD - RedD > 6 &&  controle==0)
	{
	motor(esquerda)=0;
	motor(direita)=0;
	sleep(100);
	controle=3;
	}
	else
	{
	motor(esquerda)=0;
	motor(direita)=0;
	sleep(100);
	controle=1;
	}
	}
	}
	motor(esquerda)=0;
	motor(direita)=0;
	if(controle==1)
	{
	motor(esquerda)=0;
	motor(direita)=0;

	motor(esquerda)=0;//e25
	motor(direita)=0;
	motorg(70,20,70,20);
	motorg(400,20,400,-20);
	}
	if(controle==2)
	{
	motor(esquerda)=0;
	motor(direita)=0;

	motorg(70,20,70,20);
	motorg(400,-20,400,20);
	playSound(nNumbOfSystemSounds);
	}
	if(controle==3)
	{
	//////setLEDColor(ledRedFlash);
	motor(esquerda)=0;
	motor(direita)=0;
	playSound(nNumbOfSystemSounds);
	motor(esquerda)=0;
	motor(direita)=0;
	motorg(50,-30,50,-30);
	motorg(380,20,380,-20);
	motorg(20,70,20,70);
	}

	if(controle==4)
	{

	//////setLEDColor(ledRedFlash);
	motor(esquerda)=0;
	motor(direita)=0;
	playSound(nNumbOfSystemSounds);
	motor(esquerda)=0;
	motor(direita)=0;
	motorg(50,-30,50,-30);
	motorg(380,-30,380,30);
	motorg(70,20,70,20);
	}
	if(controle==5)
	{
	motorg(800,-30,800,30);
	motorg(90,-30,90,-30);
	}
	controle=0;
	startTask(verdeFalsoD);
	startTask(verdeFalsoE);
	startTask(verdE);
	startTask(verdD);

	startTask(seguir);
	}//fim do dist=1

	if(ladoObst == 2)// sem curva de noventa (vira90 direto no obst)

	{

	stopTask(tela);
	stopTask(verdeFalsoD);
	stopTask(verdeFalsoE);
	stopTask(verdD);
	stopTask(verdeE);
	stopTask(seguir);


	motor(esquerda)=0;
	motor(direita)=0;
	sleep(100);




	moveMotorTarget(esquerda, 480, 60);
	moveMotorTarget(direita, 480, -60);
	waitUntilMotorStop(esquerda);
	waitUntilMotorStop(direita);


	while((luzD>=pretoD+5||luzE>=pretoE+5) && graus>-450)
	{

	if(luzD>=pretoD+5&&luzE>=pretoE+5)
	{
	motor(esquerda)=-10;
	motor(direita)=-10;

	}//fim do if td branco

	if(luzD<=pretoD+5)
	{
	motor(direita)=10;
	motor(esquerda)=-10;


	}//fim do preto na direita

	if(luzE<=pretoE+5)
	{
	motor(direita)=-10;
	motor(esquerda)=10;

	}//preto no esq


	}//fim do while de alihamento
	motor(esquerda)=0;
	motor(direita)=0;





	while(distL<15)
	{
	motor[direita]=-51;
	motor[esquerda]=-51;
	}



	motor[direita]=0;
	motor[esquerda]=0;



	moveMotorTarget(direita, 920, -45);
	waitUntilMotorStop(direita);






	while(distL>15)
	{

	motor(esquerda)=-55;
	motor(direita)=-55;
	}

	while(distL<15)
	{
	motor(esquerda)=-40;
	motor(direita)=-40;
	}

	motor(esquerda)=0;
	motor(direita)=0;


	moveMotorTarget(esquerda, 200,-25);
	moveMotorTarget(direita, 200, -25);
	waitUntilMotorStop(esquerda);
	waitUntilMotorStop(direita);


	moveMotorTarget(esquerda, 480, 25);
	moveMotorTarget(direita, 480, -25);
	waitUntilMotorStop(esquerda);
	waitUntilMotorStop(direita);


	moveMotorTarget(esquerda, 500,- 25);
	moveMotorTarget(direita, 500, -25);
	waitUntilMotorStop(esquerda);
	waitUntilMotorStop(direita);



	while(luzE > pretoE+10)
	{
	motor[esquerda]=-25;
	motor[direita]=-25;
	}
	motor[esquerda]=0;
	motor[direita]=0;


	moveMotorTarget(esquerda,250,30);
	moveMotorTarget(direita,250,30);
	waitUntilMotorStop(direita);
	waitUntilMotorStop(esquerda);



	moveMotorTarget(esquerda,480,30);
	moveMotorTarget(direita,480,-30);
	waitUntilMotorStop(direita);
	waitUntilMotorStop(esquerda);


	startTask(verdeFalsoD);
	startTask(verdeFalsoE);
	startTask(verdD);
	startTask(verdE);

	startTask (seguir);

	}//fim do obst=2

	if(ladoObst==3)
	{
	stopTask(verdeFalsoD);
	stopTask(verdeFalsoE);
	stopTask(verdD);
	stopTask(verdE);                  //paratasks
	stopTask(seguir);
	i2cAtivado=1;
	teste=i2c_msg(8,1,1,7,0,0,0,0);
	motorg(160,-40,160,-40);

	motorg(520,-30,520,30);

	while((luzD>=pretoD+23||luzE>=pretoE+23) && graus>-450) //while do alinhamento
	{
	if(luzD>=pretoD+38&&luzE>=pretoE+38)
	{
	motor(esquerda)=-10;
	motor(direita)=-10;

	}//fim do if td branco
	if(luzD<=pretoD+38)
	{
	motor(direita)=10;
	motor(esquerda)=-10;
	}//fim do preto na direita
	if(luzE<=pretoE+38)
	{
	motor(direita)=-10;
	motor(esquerda)=10;
	}//preto no esq
	}//fim do while de alihamento
	motor(esquerda)=0;
	motor(direita)=0;

	sleep(1000);
	if(distD>8)
	{
	while(distD>8)
	{
	motor[direita]=40;
	motor[esquerda]=40;
	}
	}
	parar();
	while(distD<8 && dist>=10)
	{
	motor[direita]=40;
	motor[esquerda]=40;
	playTone(100,1);
	}
	parar();

	wait1Msec(100);
	if(dist<=9)
	{

	if(distD>=8)
	{
	while(distD>=8)
	{
	andar(-40,-40);

	}

	while(distD<8)
	{
	andar(-40,-40);
	}

	parar();

	motorg(280,-40,280,-40);

	motorg(520,40,520,-40);

	while(distE>8)
	{
	andar(40,40);
	}
	parar();
	while(distE<8)
	{
	andar(40,40);
	}
	parar();

	motorg(340,40,340,40);

	motorg(520,-40,520,40);

	motorg(150,40,150,40);

	while(luzE>=pretoE+10)
	{
	andar(20,20);

	}
	parar();

	motorg(180,40,180,40);

	motorg(520,40,520,-40);


	}
	}
	else{
	motorg(400,40,400,40);

	motorg(520,40,520,-40);

	while(distD>8)
	{
	andar(40,40);

	}
	parar();
	while(distD<8)
	{
	andar(40,40);
	}
	parar();

	motorg(400,40,400,40);

	motorg(520,40,520,-40);

	motorg(100,40,100,40);

	while(luzD>pretoD+20)
	{
	andar(20,20);
	}
	parar();


	motorg(120,40,120,40);

	motorg(520,-40,520,40);

	andar(-25,-25);
	sleep(1200);
	parar();
	}
	i2cAtivado=0;
	teste=i2c_msg(8,1,1,8,0,0,0,0);
	}
	}

	startTask(verdeFalsoD);
	startTask(verdeFalsoE);
	startTask(verdE);
	startTask(verdD);
	startTask(seguir);

	}
	*/
}//fin do if
//fim do while

//fim da task

task verdE()
{
	verdeFalsoL=false;
	startTask(verdeFalsoE);
	while(1)
	{
		if( luzE > verdeE - 15 && luzE < verdeE +15 && GreenE - RedE > 6)
		{	//////setLEDColor(ledOrange);
			stopTask(obstaculo);
			stopTask(seguir);
			stopTask(verdD);
			stopTask(verdeFalsoD);
			stopTask(verdeFalsoE);
			motor(esquerda)=0;
			motor(direita)=0;
			sleep(500);
			if(luzD > verdeD - 25 && luzD < verdeD +25 && GreenD - RedD > 4)
			{
				moveMotorTarget(direita,150,50);
				moveMotorTarget(esquerda,150,50);
				waitUntilMotorStop(direita);
				waitUntilMotorStop(esquerda);


				moveMotorTarget(direita,1000,-50);
				moveMotorTarget(esquerda,1000,50);
				waitUntilMotorStop(direita);
				waitUntilMotorStop(esquerda);

				startTask(seguir);
				startTask(obstaculo);
				startTask(verdeFalsoD);
				startTask(verdeFalsoE);
				startTask(verdD);
				//////setLEDColor(ledGreen);

				sleep(100);

			}

			else
			{
				stopTask(obstaculo);
				stopTask(seguir);
				stopTask(verdD);
				stopTask(verdeFalsoD);


				motor(esquerda)=0;
				motor(direita)=0;
				playSound(soundFastUpwardTones);

				clearTimer(T3);


				//motorg(150,30,150,30);

				//	motorg(330,-30,330,30);

				while(time1[T3]<1250)
				{
					motor(esquerda)=30+(luzE-cinzaSE)*kpp;
					motor(direita)=30;
				}

				motor[esquerda]=0;
				motor[direita]=0;



				startTask(seguir);
				startTask(obstaculo);
				startTask(verdeFalsoD);
				startTask(verdeFalsoE);
				startTask(verdD);





			}

		}
	}
}

task verdD()
{
	verdeFalsoR=false;
	startTask(verdeFalsoD);
	while(1)
	{
		if(luzD > verdeD - 15 && luzD < verdeD + 15 && GreenD - RedD > 6)
		{
			//////setLEDColor(ledOrange);
			stopTask(obstaculo);
			stopTask(seguir);
			stopTask(verdE);
			stopTask(verdeFalsoD);
			stopTask(verdeFalsoE);
			motor(esquerda)=0;
			motor(direita)=0;
			sleep(500);
			if( luzE > verdeE - 25 && luzE < verdeE +25 && GreenE - RedE > 4)

			{



				moveMotorTarget(direita,150,50);
				moveMotorTarget(esquerda,150,50);
				waitUntilMotorStop(direita);
				waitUntilMotorStop(esquerda);



				moveMotorTarget(direita,1000,-50);
				moveMotorTarget(esquerda,1000,50);
				waitUntilMotorStop(direita);
				waitUntilMotorStop(esquerda);



				startTask(seguir);
				startTask(obstaculo);
				startTask(verdeFalsoD);
				startTask(verdeFalsoE);
				startTask(verdE);
				//////setLEDColor(ledGreen);

			}

			else
			{
				stopTask(obstaculo);
				stopTask(seguir);
				stopTask(verdE);
				stopTask(verdeFalsoD);
				stopTask(verdeFalsoE);
				motor(esquerda)=0;
				motor(direita)=0;


				clearTimer(T3);




				while(time1[T3]<1250)
				{
					motor(direita)=30+(luzD-cinzaSD)*kpp;
					motor(esquerda)=30;

				}

				motor[esquerda]=0;
				motor[direita]=0;




				startTask(seguir);
				startTask(obstaculo);
				startTask(verdeFalsoD);
				startTask(verdeFalsoE);
				startTask(verdE);


				sleep(100);
			}
		}
	}
}
task verdeFalsoD()

{
	while(1)
	{
		if((luzD<=pretoD) && verdeFalsoR == false )
		{
			clearTimer(T1);
			verdeFalsoR = true;

			while(time1[T1] <=1000 && verdeFalsoR == true)
			{
				if(luzD > verdeD - 15 && luzD < verdeD + 15 && GreenD - RedD > 6)

				{
					stopTask(seguir);
					stopTask(verdD);

					motor(direita)= 0;
					motor(esquerda)=0;

					moveMotorTarget(direita,100,70);
					moveMotorTarget(esquerda,100,70);
					waitUntilMotorStop(direita);
					waitUntilMotorStop(esquerda);

					startTask(seguir);
					startTask(verdD);
					startTask(obstaculo);
					stopTask(verdeFalsoE);

				}//fecha if


			}//fecha while 1

			verdeFalsoR = false;

		}// fecha if


	}

}

task verdeFalsoE()

{
	while(1)
	{
		if((luzE<=pretoE) && verdeFalsoL == false )
		{
			clearTimer(T1);
			verdeFalsoL = true;

			while(time1[T1] <=1000 && verdeFalsoL == true)
			{
				if(luzE > verdeE - 15 && luzE < verdeE + 15 && GreenE - RedE > 6)

				{
					stopTask(seguir);
					stopTask(verdE);

					motor(direita)= 0;
					motor(esquerda)=0;

					moveMotorTarget(direita,100,70);
					moveMotorTarget(esquerda,100,70);
					waitUntilMotorStop(direita);
					waitUntilMotorStop(esquerda);



					startTask(seguir);
					startTask(verdE);


				}


			}
			verdeFalsoL = false;
		}// fecha if


	}
}
task verSala3()
{
	while(1)
	{
		int s=0;
		long t=0;
		int l=0;
		int po=1;

		if(distD<13&&distE<13)
		{
			setLEDColor(ledOrange);
			clearTimer(T4);

			while(distD<13 && distE<13)
			{
				playTone(10,10);
				//if(luzE>=cinzaE-20&&luzD>=cinzaD-20&&luzE<cinzaE+20&&luzD<cinzaD+20)
				//{
				//	s=1;setLEDColor(ledRed);
				//	}
			}
			t=time1[T4];
			if(distD>=13)
			{
				l=1;
			}else l=2;
			while(t+500>time1[T4])
			{
				/*if(luzE>=cinzaE-20&&luzD>=cinzaD-20&&luzE<cinzaE+20&&luzD<cinzaD+20)
				{
				s=1;setLEDColor(ledRed);
				}*/
				if(l==1)
				{
					if(distE>20)po=0;
				}else if(distD>20)po=0;
			}
			clearTimer(T4);

			if(t>2000&&po==1)
			{
				setLEDColor(ledGreen);
				while(2000>time1[T4])
				{
					if(luzE>=brancoE-20&&luzD>=brancoD-20&&luzE<brancoE+20&&luzD<brancoD+20)
					{
						startTask(sala3);
					}
				}
			}
		}
	}
}

task sala3()
{
	int lado=0;
	int pat=0;
	stopTask(seguir);
	stopTask(verdeFalsoD);
	stopTask(verdeFalsoE);
	stopTask(verdD);
	stopTask(verdeE);
	stopTask(seguir);
	stopTask(obstaculo);
	stopTask(verSala3);
	parar();


	if(distD>15)
	{
		////setLEDColor(ledRedFlash);
		lado=1;

	}

	else lado=2;

	if(lado==1)//entrada esq

	{	sleep(100);
		motorg(300,70,300,70);
		sleep(100);
		motorg(575,-70,575,70);
		if(dist>6)
		{
			while(dist>4)
			{
				andar(40,40);
			}
			parar();


		}

		motorg(100,40,100,40);

		andar(20,20);
		sleep(2000);
		parar();

		motorg(240,-50,240,-50);

		motorg(565,40,565,-40);

		while(dist>4)
		{
			andar(50,50);
		}parar();

		if(luzE<=pretoE+15)
		{
			pat=1;
		}
		else pat=10;

		if(pat==1)
		{////setLEDColor(ledOrangePulse);


			andar(20,20);
			sleep(2100);
			parar();

			motorg(275,-50,275,-50);
			motorg(575,-40,575,40);
			motor(traz)=-100;
			if(dist>6)
			{while(dist>6)
					andar(40,40);
			}
			andar(20,20);
			sleep(2000);
			parar();
			motor(traz)=0;
			motorg(100,-50,100,-50);
			motorg(25,-50,25,50);
			motorg(1700,-40,1700,-40);
			motorg(100,50,100,-50);
			motorg(300,50,300,-50);
			motorg(100,-40,100,-40);
			motorg(450,50,450,-50);


			andar(20,20);
			sleep(1300);
			parar();

			motorg(2000,-40,2000,-40);



			motorg(100,20,100,20);

			motorg(480,-40,480,40);

			motorg(50,40,50,-40);

			motorg(1200,-40,1200,-40);

			motorg(50,-40,50,40);


			motorg(160,-40,160,-40);

			motorg(575,-40,575,40);

			motorg(400,40,400,40);
			andar(20,20);
			sleep(1700);
			parar();
			motorg(1300,-40,1300,-40);

			motorg(575,-40,575,40);
			motorg(220,40,220,40);
			andar(20,20);
			sleep(1500);
			parar();
			motorg(3000,-40,3000,-40);
			motorg(190,-40,190,-40);

			motorg(575,40,575,-40);

			motorg(550,-40,550,-40);

			motorg(200,-40,200,40);

			andar(-20,-20);
			sleep(500);
			parar();

			motor(traz)=100;
			andar(30,30);
			sleep(4000);
			parar();
			motor(traz)=0;



		}
		//fim patamar 1 e
		if(pat==10)
		{
			andar(20,20);
			sleep(1200);
			parar();

			motorg(130,-40,130,-40);

			motorg(575,50,575,-50);
			andar(-50,-50);
			sleep(2000);
			parar();

			while(dist>5)
			{
				andar(60,60);

			}parar();

			if(luzE<=pretoE+20)
			{pat=2;
			}else pat=3;






		}//pat =2 ou =3 e
		if(pat==2)
		{
			////setLEDColor(ledGreen);

			andar(20,20);
			sleep(1200);
			parar();

			motorg(270,-40,270,-40);

			motorg(575,-40,575,40);

			motorg(300,40,300,40);
			if(dist<6)
			{
				while(dist>=4)
				{
					andar(20,20);
				}	parar();

			}
			motor(traz)=-100;
			andar(20,20);
			sleep(1200);
			parar();
			motor(traz)=0;
			motorg(1500,-40,1500,-40);

			motorg(575,40,575,-40);

			motorg(100,40,100,40);

			andar(20,20);
			sleep(1700);
			parar();

			motorg(3180,-40,3180,-40);

			andar(-6,-6);
			sleep(1800);
			parar();


			motorg(560,-40,560,40);

			motorg(620,-40,620,-40);

			motorg(560,-40,560,40);


			motorg(200,40,200,40);

			andar(20,20);
			sleep(1700);
			parar();

			motorg(3100,-40,3100,-40);
			andar(-6,-6);
			sleep(1700);
			parar();

			motorg(560,-40,560,40);
			motorg(100,20,100,20);
			andar(20,20);
			sleep(2000);
			parar();
			motorg(1600,-40,1600,-40);

			motorg(20,40,200,-40);

			motorg(180,-40,180,-40);

			andar(40,40);
			motor(traz)=100;
			sleep(4000);
			parar();
			motor(traz)=0;
		}//

		if(pat==3)
		{
			////setLEDColor(ledOff);

			andar(20,20);
			sleep(1200);
			parar();

			motorg(240,-40,240,-40);

			motorg(575,-40,575,40);

			motorg(400,40,400,40);
			motor(traz)=-100;
			andar(20,20);
			sleep(1200);
			parar();
			motor(traz)=0;
			motorg(1500,-40,1500,-40);

			motorg(575,40,575,-40);

			motorg(100,40,100,40);

			andar(20,20);
			sleep(1200);
			parar();

			motorg(3180,-40,3180,-40);

			andar(-6,-6);
			sleep(1800);
			parar();


			motorg(560,-40,560,40);

			motorg(620,-40,620,-40);

			motorg(560,-40,560,40);


			motorg(200,40,200,40);

			andar(20,20);
			sleep(1200);
			parar();

			motorg(3170,-40,3170,-40);

			andar(30,30);
			motor(traz)=100;
			sleep(4000);
			parar();
			motor(traz)=0;

		}
	}



	if(lado==2)//entrada direita
	{
		sleep(100);
		motorg(300,70,300,70);
		sleep(100);
		motorg(565,70,565,-70);
		if(dist>6)
		{
			while(dist>4)
			{
				andar(40,40);
			}
			parar();


		}

		motorg(100,40,100,40);

		andar(20,20);
		sleep(2000);
		parar();

		motorg(240,-50,240,-50);

		motorg(565,-40,565,40);

		while(dist>4)
		{
			andar(50,50);
		}parar();

		if(luzE<=pretoE+15)
		{
			pat=1;
		}

		else pat=10;

		if(pat==1)//patamar posição 1 com entrada pela direita
		{////setLEDColor(ledOrangePulse);


			andar(20,20);
			sleep(2100);
			parar();

			motorg(275,-50,275,-50);
			motorg(565,40,565,-40);
			motor(traz)=-100;
			if(dist>6)
			{while(dist>6)
					andar(40,40);
			}
			andar(20,20);
			sleep(2000);
			parar();
			motor(traz)=0;
			motorg(400,-50,400,-50);
			playTone(100,100);
			motorg(25,50,25,-50);
			motorg(1700,-40,1700,-40);
			motorg(100,-50,100,50);
			motorg(300,-50,300,50);
			motorg(100,-40,100,-40);
			motorg(450,-50,450,50);


			andar(20,20);
			sleep(1300);
			parar();

			motorg(2000,-40,2000,-40);



			motorg(50,20,50,20);

			motorg(480,40,480,-40);

			motorg(50,40,50,-40);

			motorg(1100,-40,1100,-40);




			motorg(160,-40,160,-40);

			motorg(565,40,565,-40);

			motorg(600,40,600,40);
			andar(20,20);
			sleep(1700);
			parar();
			motorg(1700,-40,1700,-40);

			motorg(565,40,565,-40);
			motorg(220,40,220,40);
			andar(20,20);
			sleep(1500);
			parar();
			motorg(3000,-40,3000,-40);
			motorg(190,-40,190,-40);

			motorg(565,-40,565,40);

			motorg(40,-40,40,-40);

			motorg(100,40,100,-40);

			andar(-20,-20);
			sleep(500);
			parar();

			motor(traz)=100;
			andar(30,30);
			sleep(4000);
			parar();
			motor(traz)=0;



		}
		if(pat==10)//verifica
		{
			andar(20,20);
			sleep(1200);
			parar();

			motorg(130,-40,130,-40);

			motorg(565,-50,565,50);
			andar(-50,-50);
			sleep(2000);
			parar();




			while(dist>5)
			{
				andar(60,60);

			}parar();

			if(luzE<=pretoE+20)
			{pat=2;
			}else pat=3;






		}
		if(pat==2)
		{
			////setLEDColor(ledGreen);

			andar(20,20);
			sleep(1200);
			parar();

			motorg(240,-40,240,-40);

			motorg(565,40,565,-40);

			motorg(400,40,400,40);
			motor(traz)=-100;
			andar(20,20);
			sleep(1200);
			parar();
			motor(traz)=0;
			motorg(1500,-40,1500,-40);

			motorg(575,-40,575,40);

			motorg(100,40,100,40);

			andar(20,20);
			sleep(1200);
			parar();

			motorg(3180,-40,3180,-40);

			andar(-6,-6);
			sleep(1800);
			parar();


			motorg(560,40,560,-40);

			motorg(620,-40,620,-40);

			motorg(560,40,560,-40);


			motorg(200,40,200,40);

			andar(20,20);
			sleep(1200);
			parar();

			motorg(3100,-40,3100,-40);
			andar(-6,-6);
			sleep(1800);
			parar();

			motorg(560,40,560,-40);
			motorg(100,20,100,20);
			andar(20,20);
			sleep(1200);
			parar();
			motorg(1600,-40,1600,-40);

			motorg(200,-40,200,40);

			motorg(100,-40,100,-40);

			andar(40,40);
			motor(traz)=100;
			sleep(4000);
			parar();
			motor(traz)=0;
		}

		if(pat==3)
		{
			////setLEDColor(ledOff);

			andar(20,20);
			sleep(1200);
			parar();

			motorg(240,-40,240,-40);

			motorg(565,40,565,-40);

			motorg(400,40,400,40);
			motor(traz)=-100;
			andar(20,20);
			sleep(1200);
			parar();
			motor(traz)=0;
			motorg(1500,-40,1500,-40);

			motorg(565,-40,565,40);

			motorg(100,40,100,40);

			andar(20,20);
			sleep(1200);
			parar();

			motorg(3180,-40,3180,-40);

			andar(-6,-6);
			sleep(1800);
			parar();


			motorg(560,40,560,-40);

			motorg(620,-40,620,-40);

			motorg(560,40,560,-40);


			motorg(200,40,200,40);

			andar(20,20);
			sleep(1200);
			parar();

			motorg(3170,-40,3170,-40);

			andar(30,30);
			motor(traz)=100;
			sleep(4000);
			parar();
			motor(traz)=0;


		}///////
	}
}
