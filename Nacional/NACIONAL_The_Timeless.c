#pragma config(Sensor, S1,     ARDU,           sensorI2CCustom)
#pragma config(Sensor, S2,     corDir,         sensorEV3_Color, modeEV3Color_RGB_Raw)
#pragma config(Sensor, S3,     corEsq,         sensorEV3_Color, modeEV3Color_RGB_Raw)
#pragma config(Motor,  motorA,          traz,          tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorB,          esquerda,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          direita,       tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int d=3;
float pp=3.14;

void motorg (int grausE, int forcae , int grausD, int forcad)
{
	moveMotorTarget(esquerda,grausE,forcae);
	moveMotorTarget(direita,grausD,forcad);
	waitUntilMotorStop(esquerda);
	waitUntilMotorStop(direita);
	sleep(100);
}

void parar()
{
	motor[direita]=0;
	motor[esquerda]=0;
	waitUntilMotorStop(esquerda);
	waitUntilMotorStop(direita);
}

void andar(int forcaee, int forcadd)
{
	motor[esquerda]=forcaee;
	motor[direita]=forcadd;

}

void andacm(int cm,int forcaa)
{


	moveMotorTarget(esquerda,forcaa,(pp*d/360)*cm);
	moveMotorTarget(direita,forcaa,(pp*d/360)*cm);
	waitUntilMotorStop(esquerda);
	waitUntilMotorStop(direita);

}


int distF, erro, vnD, vnE, luzE, luzD, FE, FD, lastErro, distL, distBD, distBE;
int dist, i2cAtivado=0;


float kp=1.6;
float kd=20;

bool verdeFalsoR;

int graus;
int Fmin=35;
int grause;
int controle;
int distD;
int distE;

int teste;


int pretoE=16;
int pretoD=21;//de 15 ate 32


int brancoE=190;
int brancoD=176;



int verdeE= 30;
int verdeD=26;


int cinzaE=130;
int cinzaD=137;

int x;
byte I2Cmessage[22];
char I2Creply[20];
int cinzaSE=170;
int cinzaSD=170;
int ladoObst=3;

int FminO=20;
bool verdeFalsoL;
int incli;

int controle1;
float kpp=0.3;

long RedE, RedD, GreenE, GreenD, BlueE, BlueD;

task sensores() ;//pronta
task tela() ;//pronta
task seguir();//pronta
task obstaculo();//pronto
task verdE();//pronto
task verdD();//pronto
task verdeFalsoE();//pronta
task verdeFalsoD();//pronta
task verSala3();
task sala3();
int i2c_msg(byte rec_address, int message_size,int return_size, ubyte byte0, ubyte byte1, ubyte byte2, ubyte byte3,ubyte byte4)

{
	memset(I2Creply, 0, sizeof(I2Creply));

	message_size = message_size+3;

	I2Cmessage[0] = message_size;
	I2Cmessage[1] = rec_address*2;
	I2Cmessage[2] = byte0;
	I2Cmessage[3] = byte1;
	I2Cmessage[4] = byte2;
	I2Cmessage[5] = byte3;
	I2Cmessage[6] = byte4;

	sendI2CMsg(S1, &I2Cmessage[0], return_size);
	wait1Msec(25);

	readI2CReply(S1, &I2Creply[0], return_size);

	x = I2Creply[0];

	wait1Msec(10);

	return x;

}



task main()

{



	motor(traz)=100;
	sleep(2000);
	//andar(100,100);
	motor(traz)=0;
	setMotorBrakeMode(traz,0);

	startTask(sensores);
	startTask (tela);

	/*	resetGyro(giroscopio);
	sleep(100);
	while(incli<90)
	{
	andar(40,-40)


	}parar();*/
	while(1)
	{
		if(getButtonPress(buttonRight))
		{




			startTask(seguir);
			startTask(obstaculo);
			startTask(verdE);
			startTask(verdD);
			startTask(verdeFalsoD);
			startTask(verdeFalsoE);
			startTask(verSala3);
			//startTask(curva90);
		}
		sleep(10);
	}//fim do while

}//fim da task mein

task sensores()
{
	while(1)
	{
		luzE=SensorValue[corEsq];//descobre valor dos sensore Direito
		luzD=SensorValue[corDir];//descobre valor do sensor Esquerdo
		//incli=getGyroDegrees(giroscopio);
		dist=i2c_msg(8,1,1,2,0,0,0,0);
		distD=i2c_msg(8,1,1,3,0,0,0,0);
		distE=i2c_msg(8,1,1,4,0,0,0,0);
		distBE=i2c_msg(8,1,1,5,0,0,0,0);
		distBD=i2c_msg(8,1,1,6,0,0,0,0);

		getColorRGB(corDir,RedD,GreenD,BlueD);//descobre valor do RGB
		getColorRGB(corEsq, RedE, GreenE,BlueE);//descobre valor do sensor
		graus=getMotorEncoder(direita);//descobre valor do ENCOLDERDIREITO
		grause=getMotorEncoder(esquerda);//descobre valor do ENCONDERESQUERO
		sleep(1);
	}
}
task tela()
{
	while(1)



	{
		//displayBigTextLine(2,"RedD: %d",RedD);
		//	displayBigTextLine(4,"RedE: %d",RedE);
		//	displayBigTextLine(6,"GreenD:%d",GreenD);
		//displayBigTextLine(8,"GreenE:%d",GreenE);

		displayBigTextLine(8,"senbe: %d",distBD);//MOSTRA OS VALORES NA TELA
		displayBigTextLine(10,"distD: %d", distD);//MOSTRA OS VALORES NA TELA
		displayBigTextLine(12,"distE: %d", distE);//MOSTRA OS VALORES NA TELA
		displayBigTextLine(2,"SensorE: %d",luzE);//MOSTRA OS VALORES NA TELA
		displayBigTextLine(4,"SensorD: %d",luzD);//MOSTRA OS VALORES NA TELA
		displayBigTextLine(6,"senbd: %d",distBE);
		displayBigTextLine(14,"distF: %d",dist);


		sleep(500);
	}
}


task seguir()//seguir linha
{
	while(1)
	{
		vnE = (100*(luzE-pretoE))/(brancoE-pretoE);//calcula valor normalizado Esquerdo
		vnD = (100*(luzD-pretoD))/(brancoD-pretoD);//calcula valor normalizado Direito

		if (vnD>100) vnD=100;//SE O VALOR DO VND FOR ALTO MOTOR RAPIDO
			if (vnD<0) vnD=0;//se vnd for baixa motor lento
			if (vnE>100) vnE=100;//SE O VALOR DO VNE FOR ALTO MOTOR RAPIDO
			if (vnE<0) vnE=0;//se vnd for baixa motor lento

		erro=vnE-vnD;//descobre erro

		FE=Fmin+(kp*erro)+kd*(erro-lastErro);//descobre força dos motores
		FD=Fmin-(kp*erro)-kd*(erro-lastErro);//descobre força dos motores

		lastErro=erro;//lastErro

		motor[esquerda]=FE;//faz ele anda
		motor[direita]=FD;//faz ele anda

		sleep(10);//quantas vezes ele vai checar o sensor
	}
}





//////////////////////////OBSTACULO////////////////////////////////////////////////

task obstaculo()
{
	while(1)
	{
		if (dist<=5 && dist!=0)//se a distancia ficar pequena
		{
			sleep(10);
			if (dist<=4 && dist!=0)
			{
				if(ladoObst==3)
				{//abre lado obst3
					stopTask(verdeFalsoD);
					stopTask(verdeFalsoE);
					stopTask(verdD);
					stopTask(verdE);                  //paratasks
					stopTask(seguir);

					motorg(160,-40,160,-40);

					motorg(520,40,520,-40);

					while((luzD>=pretoD+27||luzE>=pretoE+27) && graus>-450) //while do alinhamento
					{
						if(luzD>=pretoD+40&&luzE>=pretoE+40)
						{
							motor(esquerda)=-10;
							motor(direita)=-10;

						}//fim do if td branco
						if(luzD<=pretoD+40)
						{
							motor(direita)=10;
							motor(esquerda)=-10;
						}//fim do preto na direita
						if(luzE<=pretoE+40)
						{
							motor(direita)=-10;
							motor(esquerda)=10;
						}//preto no esq
					}//fim do while de alihamento

					motor(esquerda)=0;
					motor(direita)=0;

					sleep(1000);
					if(distE>8)
					{
						while(distE>8)
						{
							motor[direita]=40;
							motor[esquerda]=40;
						}
					}
					parar();

					while(distE<=8 && dist>=10 && distBD>=10 && distBE>=10)
					{
						motor[direita]=40;
						motor[esquerda]=40;
						playTone(100,1);
					}

					parar();

					wait1Msec(100);
					if(dist<=10 || distBD<=10 || distBD<=10)
					{
						playTone(100,10);
						if(distD>=8)
						{
							while(distD>=8)
							{
								andar(-40,-40);
							}
						}
						while(distD<8)
						{
							andar(-40,-40);
						}

						parar();

						motorg(280,-40,280,-40);

						motorg(520,40,520,-40);

						while(distE>8)
						{
							andar(40,40);
						}
						parar();
						while(distE<8)
						{
							andar(40,40);
						}
						parar();

						motorg(340,40,340,40);

						motorg(520,-40,520,40);

						motorg(150,40,150,40);

						while(luzE>=pretoE+10)
						{
							andar(20,20);

						}
						parar();

						motorg(180,40,180,40);

						motorg(520,40,520,-40);


					}

					else{
						motorg(400,40,400,40);

						motorg(520,-40,520,40);

						while(distE>8)
						{
							andar(40,40);

						}
						parar();
						while(distE<8)
						{
							andar(40,40);
						}
						parar();

						motorg(400,40,400,40);

						motorg(540,-40,540,40);

						motorg(130,40,130,40);

						while(luzD>pretoD+20)
						{
							andar(20,20);
						}
						parar();


						motorg(120,40,120,40);

						motorg(520,40,520,-40);

						andar(-25,-25);
						sleep(1200);
						parar();
					}

				}
			}

			startTask(verdeFalsoD);
			startTask(verdeFalsoE);
			startTask(verdE);
			startTask(verdD);
			startTask(seguir);
		}
	}
}

//fim do if
//fim do while

//fim da task obstaculo

task verdE()
{
	verdeFalsoL=false;
	startTask(verdeFalsoE);
	while(1)
	{
		if( luzE > verdeE - 15 && luzE < verdeE +15 && GreenE - RedE > 6)
		{	//////setLEDColor(ledOrange);
			stopTask(obstaculo);
			stopTask(seguir);
			stopTask(verdD);
			stopTask(verdeFalsoD);
			stopTask(verdeFalsoE);
			motor(esquerda)=0;
			motor(direita)=0;
			sleep(500);
			if(luzD > verdeD - 25 && luzD < verdeD +25 && GreenD - RedD > 4)
			{
				moveMotorTarget(direita,150,50);
				moveMotorTarget(esquerda,150,50);
				waitUntilMotorStop(direita);
				waitUntilMotorStop(esquerda);


				moveMotorTarget(direita,1000,-50);
				moveMotorTarget(esquerda,1000,50);
				waitUntilMotorStop(direita);
				waitUntilMotorStop(esquerda);

				startTask(seguir);
				startTask(obstaculo);
				startTask(verdeFalsoD);
				startTask(verdeFalsoE);
				startTask(verdD);
				//////setLEDColor(ledGreen);

				sleep(100);

			}

			else
			{
				stopTask(obstaculo);
				stopTask(seguir);
				stopTask(verdD);
				stopTask(verdeFalsoD);


				motor(esquerda)=0;
				motor(direita)=0;
				playSound(soundFastUpwardTones);

				clearTimer(T3);


				//motorg(150,30,150,30);

				//	motorg(330,-30,330,30);

				while(time1[T3]<1300)
				{
					motor(esquerda)=30+(luzE-cinzaSE)*kpp;
					motor(direita)=30;
				}

				motor[esquerda]=0;
				motor[direita]=0;



				startTask(seguir);
				startTask(obstaculo);
				startTask(verdeFalsoD);
				startTask(verdeFalsoE);
				startTask(verdD);





			}

		}
	}
}

task verdD()
{
	verdeFalsoR=false;
	startTask(verdeFalsoD);
	while(1)
	{
		if(luzD > verdeD - 15 && luzD < verdeD + 15 && GreenD - RedD > 6)
		{
			//////setLEDColor(ledOrange);
			stopTask(obstaculo);
			stopTask(seguir);
			stopTask(verdE);
			stopTask(verdeFalsoD);
			stopTask(verdeFalsoE);
			motor(esquerda)=0;
			motor(direita)=0;
			sleep(500);
			if( luzE > verdeE - 25 && luzE < verdeE +25 && GreenE - RedE > 4)

			{



				moveMotorTarget(direita,150,50);
				moveMotorTarget(esquerda,150,50);
				waitUntilMotorStop(direita);
				waitUntilMotorStop(esquerda);



				moveMotorTarget(direita,1000,-50);
				moveMotorTarget(esquerda,1000,50);
				waitUntilMotorStop(direita);
				waitUntilMotorStop(esquerda);



				startTask(seguir);
				startTask(obstaculo);
				startTask(verdeFalsoD);
				startTask(verdeFalsoE);
				startTask(verdE);
				//////setLEDColor(ledGreen);

			}

			else
			{
				stopTask(obstaculo);
				stopTask(seguir);
				stopTask(verdE);
				stopTask(verdeFalsoD);
				stopTask(verdeFalsoE);
				motor(esquerda)=0;
				motor(direita)=0;


				clearTimer(T3);




				while(time1[T3]<1250)
				{
					motor(direita)=30+(luzD-cinzaSD)*kpp;
					motor(esquerda)=30;

				}

				motor[esquerda]=0;
				motor[direita]=0;




				startTask(seguir);
				startTask(obstaculo);
				startTask(verdeFalsoD);
				startTask(verdeFalsoE);
				startTask(verdE);


				sleep(100);
			}
		}
	}
}
task verdeFalsoD()

{
	while(1)
	{
		if((luzD<=pretoD) && verdeFalsoR == false )
		{
			clearTimer(T1);
			verdeFalsoR = true;

			while(time1[T1] <=1000 && verdeFalsoR == true)
			{
				if(luzD > verdeD - 15 && luzD < verdeD + 15 && GreenD - RedD > 6)

				{
					stopTask(seguir);
					stopTask(verdD);

					motor(direita)= 0;
					motor(esquerda)=0;

					moveMotorTarget(direita,100,70);
					moveMotorTarget(esquerda,100,70);
					waitUntilMotorStop(direita);
					waitUntilMotorStop(esquerda);

					startTask(seguir);
					startTask(verdD);
					startTask(obstaculo);
					stopTask(verdeFalsoE);

				}//fecha if


			}//fecha while 1

			verdeFalsoR = false;

		}// fecha if


	}

}

task verdeFalsoE()

{
	while(1)
	{
		if((luzE<=pretoE) && verdeFalsoL == false )
		{
			clearTimer(T1);
			verdeFalsoL = true;

			while(time1[T1] <=1000 && verdeFalsoL == true)
			{
				if(luzE > verdeE - 15 && luzE < verdeE + 15 && GreenE - RedE > 6)

				{
					stopTask(seguir);
					stopTask(verdE);

					motor(direita)= 0;
					motor(esquerda)=0;

					moveMotorTarget(direita,100,70);
					moveMotorTarget(esquerda,100,70);
					waitUntilMotorStop(direita);
					waitUntilMotorStop(esquerda);



					startTask(seguir);
					startTask(verdE);


				}


			}
			verdeFalsoL = false;
		}// fecha if


	}
}
task verSala3()
{

	bool entrou = false;

	while(1)
	{
		//int s=0;
		//long t=0;
		//int l=0;
		//int po=1;


		if(distD<13&&distE<13 && entrou == false)
		{
			setLEDColor(ledOrange);
			clearTimer(T4);

			while(distD<13 && distE<13 && time1[T4] <2000)
			{
				playTone(10,10);
				//if(luzE>=cinzaE-20&&luzD>=cinzaD-20&&luzE<cinzaE+20&&luzD<cinzaD+20)
				//{
				//	s=1;setLEDColor(ledRed);
				//	}
			}
			//sleep(1);
			if(time1[T4] >= 2000)
			{
				entrou = true;
			}

		}//fecha if

		if(entrou == true)
		{
			stopTask(verdeFalsoD);
			stopTask(verdeFalsoE);
			stopTask(verdD);
			stopTask(verdeE);
			//stopTask(seguir);
			stopTask(obstaculo);


			while(distD <= 13 && distE <= 13)
			{
				setLEDColor(ledRed);
			}

			stopTask(seguir);
			parar();
			sleep(100);

			andar(40,40);
			sleep(700);
			parar();

			startTask(sala3);

		}//fim if entrou TRUE

		/*t=time1[T4];
		if(distD>=13)
		{
		l=1;
		}else l=2;
		while(t+500>time1[T4])
		{
		/*if(luzE>=cinzaE-20&&luzD>=cinzaD-20&&luzE<cinzaE+20&&luzD<cinzaD+20)
		{
		s=1;setLEDColor(ledRed);
		}
		if(l==1)
		{
		if(distE>20)po=0;
		}else if(distD>20)po=0;
		}
		clearTimer(T4);

		if(t>2000&&po==1)
		{
		setLEDColor(ledGreen);
		while(2000>time1[T4])
		{
		if(luzE>=brancoE-20&&luzD>=brancoD-20&&luzE<brancoE+20&&luzD<brancoD+20)
		{
		startTask(sala3);
		}
		}
		}
		}*/
	}
}

task sala3()
{
	int lado=0;
	int pat=0;
	setLEDColor(ledGreen);
	//stopTask(seguir);
	//stopTask(verdeFalsoD);
	//stopTask(verdeFalsoE);
	//stopTask(verdD);
	//stopTask(verdeE);
	//stopTask(seguir);
	//stopTask(obstaculo);
	stopTask(verSala3);
	//parar();


	if(distD>15)
	{
		////setLEDColor(ledRedFlash);
		lado=1;

	}

	else lado=2;

	if(lado==1)//entrada esq

	{	sleep(100);
		motorg(300,70,300,70);
		sleep(100);
		motorg(585,-70,585,70);
		if(dist>6)
		{
			while(dist>4)
			{
				andar(40,40);
			}
			parar();


		}

		motorg(100,40,100,40);

		andar(20,20);
		sleep(2000);
		parar();

		motorg(260,-50,260,-50);

		motorg(580,40,580,-40);

		while(dist>4)
		{
			andar(50,50);
		}parar();

		if(luzE<=pretoE+15)
		{
			pat=1;
		}
		else pat=10;

		if(pat==1)
		{////setLEDColor(ledOrangePulse);


			andar(20,20);
			sleep(2100);
			parar();

			motorg(275,-50,275,-50);
			motorg(575,-40,575,40);
			motor(traz)=-100;
			if(dist>6)
			{while(dist>6)
					andar(40,40);
			}
			andar(20,20);
			sleep(2000);
			parar();
			motor(traz)=0;
			motorg(100,-50,100,-50);
			motorg(25,-50,25,50);
			motorg(1700,-40,1700,-40);
			motorg(100,50,100,-50);
			motorg(300,50,300,-50);
			motorg(100,-40,100,-40);
			motorg(450,50,450,-50);


			andar(20,20);
			sleep(1300);
			parar();

			motorg(2000,-40,2000,-40);



			motorg(100,20,100,20);

			motorg(480,-40,480,40);

			motorg(50,40,50,-40);

			motorg(1200,-40,1200,-40);

			motorg(50,-40,50,40);


			motorg(160,-40,160,-40);

			motorg(575,-40,575,40);

			motorg(400,40,400,40);
			andar(20,20);
			sleep(1700);
			parar();
			motorg(1300,-40,1300,-40);

			motorg(575,-40,575,40);
			motorg(220,40,220,40);
			andar(20,20);
			sleep(1500);
			parar();
			motorg(3000,-40,3000,-40);
			motorg(190,-40,190,-40);

			motorg(575,40,575,-40);

			motorg(550,-40,550,-40);

			motorg(200,-40,200,40);

			andar(-20,-20);
			sleep(500);
			parar();

			motor(traz)=100;
			andar(30,30);
			sleep(4000);
			parar();
			motor(traz)=0;



		}
		//fim patamar 1 e
		if(pat==10)
		{
			andar(20,20);
			sleep(1200);
			parar();

			motorg(130,-40,130,-40);

			motorg(580,50,580,-50);
			andar(-50,-50);
			sleep(2000);
			parar();

			while(dist>4)
			{
				andar(60,60);

			}parar();

			if(luzE<=pretoE+20)
			{pat=2;
			}else pat=3;






		}//pat =2 ou =3 e
		if(pat==2)
		{
			////setLEDColor(ledGreen);

			andar(20,20);
			sleep(1200);
			parar();

			motorg(270,-40,270,-40);

			motorg(580,-40,580,40);

			motorg(300,40,300,40);
			if(dist<6)
			{
				while(dist>=4)
				{
					andar(20,20);
				}	parar();

			}
			motor(traz)=-100;
			andar(20,20);
			sleep(1200);
			parar();
			motor(traz)=0;
			motorg(1500,-40,1500,-40);

			motorg(400,40,400,-40);
			motorg(100,-40,100,-40);
			motorg(200,40,200,-40);

			motorg(200,40,200,40);

			andar(20,20);
			sleep(1700);
			parar();

			motorg(3180,-40,3180,-40);

			andar(-6,-6);
			sleep(1800);
			parar();


			motorg(575,-40,575,40);

			motorg(620,-40,620,-40);

			motorg(575,-40,575,40);


			motorg(200,40,200,40);

			andar(20,20);
			sleep(1700);
			parar();

			motorg(3100,-40,3100,-40);
			andar(-6,-6);
			sleep(1700);
			parar();

			motorg(575,-40,575,40);
			motorg(100,20,100,20);
			andar(20,20);
			sleep(2000);
			parar();
			motorg(1600,-40,1600,-40);

			motorg(20,40,200,-40);

			motorg(180,-40,180,-40);

			andar(40,40);
			motor(traz)=100;
			sleep(6000);
			parar();
			motor(traz)=0;


			motorg(170,-40,170,40);

			motorg(580,50,580,-50);

			motorg(550,-40,550,-40);

			andar(-20,-20);
			sleep(1200);
			parar();

			while(dist>=5)
			{
				andar(60,60);
			}parar();

			motorg(100,40,100,40);

			andar(20,20);
			sleep(1200);
			parar();

			motorg(250,-40,250,-40);


			motorg(580,-40,580,40);
			motorg(3000,70,3000,70);

			stopAllTasks();

			}//

		if(pat==3)
		{
			////setLEDColor(ledOff);

			andar(20,20);
			sleep(1200);
			parar();

			motorg(240,-40,240,-40);

			motorg(580,-40,580,40);

			motorg(400,40,400,40);
			motor(traz)=-100;
			andar(20,20);
			sleep(1200);
			parar();
			motor(traz)=0;
			motorg(1500,-40,1500,-40);

			motorg(580,40,580,-40);

			motorg(100,40,100,40);

			andar(20,20);
			sleep(1200);
			parar();

			motorg(3180,-40,3180,-40);

			andar(-6,-6);
			sleep(1800);
			parar();


			motorg(575,-40,575,40);

			motorg(620,-40,620,-40);

			motorg(575,-40,575,40);


			motorg(200,40,200,40);

			andar(20,20);
			sleep(1200);
			parar();

			motorg(3170,-40,3170,-40);

			andar(30,30);
			motor(traz)=100;
			sleep(6000);
			parar();
			motor(traz)=0;

		}
	}



	if(lado==2)//entrada direita
	{
		sleep(100);
		motorg(300,70,300,70);
		sleep(100);
		motorg(575,70,575,-70);
		if(dist>6)
		{
			while(dist>4)
			{
				andar(40,40);
			}
			parar();


		}

		motorg(100,40,100,40);

		andar(20,20);
		sleep(2000);
		parar();

		motorg(240,-50,240,-50);

		motorg(575,-40,575,40);

		while(dist>4)
		{
			andar(50,50);
		}parar();

		if(luzE<=pretoE+15)
		{
			pat=1;
		}

		else pat=10;

		if(pat==1)//patamar posição 1 com entrada pela direita
		{////setLEDColor(ledOrangePulse);


			andar(20,20);
			sleep(2100);
			parar();

			motorg(275,-50,275,-50);
			motorg(575,40,575,-40);
			motor(traz)=-100;
			if(dist>6)
			{while(dist>6)
					andar(40,40);
			}
			andar(20,20);
			sleep(2000);
			parar();
			motor(traz)=0;
			motorg(400,-50,400,-50);
			playTone(100,100);
			motorg(25,50,25,-50);
			motorg(1700,-40,1700,-40);
			motorg(100,-50,100,50);
			motorg(300,-50,300,50);
			motorg(100,-40,100,-40);
			motorg(450,-50,450,50);


			andar(20,20);
			sleep(1300);
			parar();

			motorg(2000,-40,2000,-40);



			motorg(50,20,50,20);

			motorg(480,40,480,-40);

			motorg(50,40,50,-40);

			motorg(1100,-40,1100,-40);




			motorg(160,-40,160,-40);

			motorg(575,40,575,-40);

			motorg(600,40,600,40);
			andar(20,20);
			sleep(1700);
			parar();
			motorg(1700,-40,1700,-40);

			motorg(575,40,575,-40);
			motorg(220,40,220,40);
			andar(20,20);
			sleep(1500);
			parar();
			motorg(3000,-40,3000,-40);
			motorg(190,-40,190,-40);

			motorg(575,-40,575,40);

			motorg(40,-40,40,-40);

			motorg(100,40,100,-40);

			andar(-20,-20);
			sleep(500);
			parar();

			motor(traz)=100;
			andar(30,30);
			sleep(4000);
			parar();
			motor(traz)=0;



		}
		if(pat==10)//verifica
		{
			andar(20,20);
			sleep(1200);
			parar();

			motorg(130,-40,130,-40);

			motorg(575,-50,575,50);
			andar(-50,-50);
			sleep(2000);
			parar();




			while(dist>5)
			{
				andar(60,60);

			}parar();

			if(luzE<=pretoE+20)
			{pat=2;
			}else pat=3;






		}
		if(pat==2)
		{
			////setLEDColor(ledGreen);

			andar(20,20);
			sleep(1200);
			parar();

			motorg(240,-40,240,-40);

			motorg(575,40,575,-40);

			motorg(400,40,400,40);
			motor(traz)=-100;
			andar(20,20);
			sleep(1200);
			parar();
			motor(traz)=0;
			motorg(1500,-40,1500,-40);

			motorg(580,-40,580,40);

			motorg(100,40,100,40);

			andar(20,20);
			sleep(1200);
			parar();

			motorg(3180,-40,3180,-40);

			andar(-6,-6);
			sleep(1800);
			parar();


			motorg(575,40,575,-40);

			motorg(620,-40,620,-40);

			motorg(575,40,575,-40);


			motorg(200,40,200,40);

			andar(20,20);
			sleep(1200);
			parar();

			motorg(3100,-40,3100,-40);
			andar(-6,-6);
			sleep(1800);
			parar();

			motorg(575,40,575,-40);
			motorg(100,20,100,20);
			andar(20,20);
			sleep(1200);
			parar();
			motorg(1600,-40,1600,-40);

			motorg(200,-40,200,40);

			motorg(100,-40,100,-40);

			andar(40,40);
			motor(traz)=100;
			sleep(4000);
			parar();
			motor(traz)=0;
		}

		if(pat==3)
		{
			////setLEDColor(ledOff);

			andar(20,20);
			sleep(1200);
			parar();

			motorg(240,-40,240,-40);

			motorg(575,40,575,-40);

			motorg(400,40,400,40);
			motor(traz)=-100;
			andar(20,20);
			sleep(1200);
			parar();
			motor(traz)=0;
			motorg(1500,-40,1500,-40);

			motorg(575,-40,575,40);

			motorg(100,40,100,40);

			andar(20,20);
			sleep(1200);
			parar();

			motorg(3180,-40,3180,-40);

			andar(-6,-6);
			sleep(1800);
			parar();


			motorg(575,40,575,-40);

			motorg(620,-40,620,-40);

			motorg(575,40,575,-40);


			motorg(200,40,200,40);

			andar(20,20);
			sleep(1200);
			parar();

			motorg(3170,-40,3170,-40);

			andar(30,30);
			motor(traz)=100;
			sleep(4000);
			parar();
			motor(traz)=0;


		}///////
	}
}
